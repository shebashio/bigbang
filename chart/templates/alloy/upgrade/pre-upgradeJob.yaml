# {{- if include "alloy.shouldDeployUpgradeResources" . }}
# apiVersion: batch/v1
# kind: Job
# metadata:
#   name: bb-alloy-upgrade
#   namespace: monitoring
#   annotations:
#     "helm.sh/hook": pre-upgrade
#     "helm.sh/hook-weight": "-5"
#     "helm.sh/hook-delete-policy": hook-succeeded,hook-failed,before-hook-creation
# spec:
#   backoffLimit: 3
#   ttlSecondsAfterFinished: 480
#   template:
#     metadata:
#       labels:
#         app.kubernetes.io/name: bigbang-alloy-upgrade-job
#     spec:
#       securityContext:
#         runAsUser: 1000
#         runAsGroup: 1000
#       serviceAccountName: alloy-bb-upgrade
#       automountServiceAccountToken: true
#       containers:
#         - name: bb-alloy-upgrade
#           image: "{{ $.Values.addons.alloy.autoRollingUpgrade.image.repository }}:{{ $.Values.addons.alloy.autoRollingUpgrade.image.tag }}"
#           command:
#             - "/bin/bash"
#             - "-c"
#             - |
#               set -e  # Exit on first error
#               trap 'echo "Error occurred at line $LINENO"; exit 1' ERR

#               echo "Starting deletion of resources with label helm.toolkit.fluxcd.io/name=alloy in namespace monitoring..."
#               echo "Note: Skipping endpointslice resources"

#               # Fetch resource types
#               resource_types=$(kubectl api-resources --verbs=list --namespaced -o name | grep -v 'NAME')

#               # Debugging: Print fetched resource types
#               echo "Fetched resource types:"
#               echo "$resource_types"

#               # Fetch all resources matching label, handling errors safely
#               cmd_output=""
#               while read -r resource; do
#                   echo "Checking resource: $resource"
#                   resource_items=$(kubectl get --show-kind --ignore-not-found -l helm.toolkit.fluxcd.io/name=alloy -n monitoring "$resource" || true)
#                   if [[ -n "$resource_items" ]]; then
#                       cmd_output+="$resource_items"$'\n'
#                   fi
#               done <<< "$resource_types"

#               # Debugging: Print fetched resources
#               echo "Fetched resources:"
#               echo "$cmd_output"

#               # Exit immediately if no resources are found
#               if [[ -z "$cmd_output" ]]; then
#                   echo "No matching resources found. Exiting."
#                   exit 0
#               fi

#               # Initialize count
#               resource_count=0

#               # Process the output
#               while IFS= read -r line; do
#                   [[ -z "$line" || "$line" =~ ^NAME ]] && continue

#                   resource_with_name=$(echo "$line" | awk '{print $1}')
#                   [[ "$resource_with_name" != */* ]] && continue

#                   resource_type=$(echo "$resource_with_name" | cut -d'/' -f1)
#                   resource_name=$(echo "$resource_with_name" | cut -d'/' -f2)

#                   [[ "$resource_type" == "endpointslice"* ]] && continue

#                   ((resource_count++))
#                   echo "Deleting $resource_type/$resource_name in namespace monitoring..."
#                   kubectl delete "$resource_type" "$resource_name" -n monitoring || {
#                       echo "✗ Failed to delete $resource_type/$resource_name"
#                       exit 1
#                   }
#                   echo "✓ Successfully deleted $resource_type/$resource_name"
#               done <<< "$cmd_output"

#               echo "Resource deletion completed successfully!"
#           resources:
#             requests:
#               cpu: 100m
#               memory: 256Mi
#             limits:
#               cpu: 100m
#               memory: 256Mi
#           securityContext:
#             capabilities:
#               drop: ["ALL"]
#             readOnlyRootFilesystem: true
#             runAsNonRoot: true
#             runAsUser: 1000
#             runAsGroup: 1000
#       restartPolicy: Never
# {{- end }}
